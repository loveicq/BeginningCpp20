- [前言](#前言)
- [第1章 基本概念](#第1章-基本概念)
  - [1.3 C++程序概念](#13-c程序概念)
    - [1.3.1 源文件](#131-源文件)
  - [1.9 表示数字](#19-表示数字)
    - [1.9.1 二进制数](#191-二进制数)
    - [1.9.2 十六进制数](#192-十六进制数)
    - [1.9.3 负的二进制数](#193-负的二进制数)
    - [1.9.4 八进制数](#194-八进制数)
    - [1.9.5 Big-Endian和Little-Endian系统](#195-big-endian和little-endian系统)
    - [1.9.6 浮点数](#196-浮点数)
    - [1.11 C++源字符](#111-c源字符)
    - [1.13 练习](#113-练习)
- [第2章 基本数据类型](#第2章-基本数据类型)
  - [2.1 变量、数据和数据类型](#21-变量数据和数据类型)
    - [2.1.1 定义整形变量](#211-定义整形变量)
    - [2.1.2 零初始化](#212-零初始化)
    - [2.1.3 定义有固定值的变量](#213-定义有固定值的变量)
  - [2.2 整形字面量](#22-整形字面量)
    - [2.2.1 十进制整形字面量](#221-十进制整形字面量)
    - [2.2.2 十六进制整形字面量](#222-十六进制整形字面量)

# 前言
1. 个人学习C++的小屋,使用教材为《C++20入门实践(第6版)》。  
2. 操作系统为windows10_x64,编辑器为vscode1.101.2版,编译器为mingw15.1.0。  
⏰gogoup!  
# 第1章 基本概念  
![第1章导图](https://tc.z.wiki/autoupload/f/TCGPJbbsy8Ycjb3iVqtXI-dF-yTE5il903mGv8fj_W-yl5f0KlZfm6UsKj-HyTuv/20250725/kXm1/1073X883/Chapter1.png)
## 1.3 C++程序概念  
### 1.3.1 源文件  
```c++
// Ex1_01.cpp  

#include <iostream>  
//书中import <iostream>语句在mingw15.1.0中会报错,需改用旧方法包含头文件

int main()
{
    int answer{42};
    std::cout << "The answer to life, the universe, and everything is "
              << answer
              << std::endl;
    std::cin.get(); //解决调试时CMD窗口一闪而过的问题

    return 0;
}
```
> 🤞`知识点`  
不同方式变量初始化的差别  

| 特性         | int a = 10; (拷贝初始化) | int a{10}; (列表初始化)  |
| :----------- | :----------------------- | ------------------------ |
| 窄化转换     | 允许（可能有警告）       | 禁止（编译错误）         |
| 类初始化效率 | 可能低效（需隐式转换）   | 高效（直接调用构造函数） |
| 防止语法歧义 | 不能                     | 能                       |
| C++标准      | 所有版本                 | C++11起支持              |

## 1.9 表示数字  
### 1.9.1 二进制数  
324=3×10<sup>2</sup> + 2×10<sup>1</sup> + 4×10<sup>0</sup>  

二进制转换十进制的方法(其它进制转十进制也一样,只是进制基数不同,将2替换为其它进制的基数即可)  
1101=1×2<sup>3</sup> + 1×2<sup>2</sup> + 0×2<sup>1</sup> + 1×2<sup>0</sup>  

十进制转换二进制的方法口诀:除2取余，倒序排列。例子如下:  
| 步骤  | 十进制数 | 除以2 |  商   | 余数  |          备注          |
| :---: | :------: | :---: | :---: | :---: | :--------------------: |
|   1   |    13    | 13÷2  |   6   |   1   |       记录余数1        |
|   2   |    6     |  6÷2  |   3   |   0   |       记录余数0        |
|   3   |    3     |  3÷2  |   1   |   1   |       记录余数1        |
|   4   |    1     |  1÷2  |   0   |   1   | 记录余数1，商为0，停止 |

最终二进制数‌：倒序读余数（从步骤4到步骤1）：1（步骤4）、1（步骤3）、0（步骤2）、1（步骤1） → ‌1101‌。  

> 🤞`知识点`  
以任意n为基数表示的数,每个位数的数字是从0到n～1。十进制数为0～9,二进制数为0～1。  

> 🤞`知识点`  
十进制的基数为10,二进制的基数为2。设基数为n，如果有m位，就可以表示n<sup>m</sup>个整数,正值为0～n<sup>m</sup>-1。8位十进制数可以表示10<sup>8</sup>(100000000)个整数,正值为0～99999999；8位二进制数可以表示2<sup>8</sup>(256)个整数,正值为0～255。  

---
> 📖`拓展阅读`  
位（bit）、字节（byte）和字（word）是计算机数据存储与处理的核心单位，其层级关系和换算规则如下：
1. 基础定义与关系
    - ‌位（bit）‌  
计算机最小的数据单位，表示一个二进制位（0 或 1）。‌  
    - ‌字节（byte）‌  
‌1 字节 = 8 位‌，是存储容量的基本单位，可存储一个英文字符（如 ASCII 码）。  
    - 字（word）‌  
计算机一次处理的数据单元，由若干字节组成，长度由‌字长‌（CPU 位数）决定：
        - 16 位系统：1 字 = 2 字节 = 16 位
        - 32 位系统：1 字 = 4 字节 = 32 位
        - 64 位系统：1 字 = 8 字节 = 64 位
2. 关键概念总结  

| 单位  |   符号   |        组成关系         |            作用            |
| :---: | :------: | :---------------------: | :------------------------: |
|  位   | bit (b)  |     最小单位（0/1）     |       二进制数据基础       |
| 字节  | Byte (B) |     1 Byte = 8 bit      | 存储容量基准（如文件大小） |
|  字   | Word (W) | 1 Word = CPU位数/8 字节 |   CPU 单次处理数据的长度   |

3. 补充说明  
    - ‌字长‌：CPU 一次能处理的二进制位数，直接决定字的字节数（如 64 位 CPU 的字长为 64 位，即 8 字节）。  
    - ‌实际应用‌：
        - 位：硬件信号处理；
        - 字节：文件存储、内存地址分配；
        - 字：指令执行、数据总线传输。‌  
---

### 1.9.2 十六进制数  

表1-3  

| 十六进制 | 十进制 | 二进制 |
| :------: | :----: | :----: |
|    0     |   0    |  0000  |
|    1     |   1    |  0001  |
|    2     |   2    |  0010  |
|    3     |   3    |  0011  |
|    4     |   4    |  0100  |
|    5     |   5    |  0101  |
|    6     |   6    |  0110  |
|    7     |   7    |  0111  |
|    8     |   8    |  1000  |
|    9     |   9    |  1001  |
|    A     |   10   |  1010  |
|    B     |   11   |  1011  |
|    C     |   12   |  1100  |
|    D     |   13   |  1101  |
|    E     |   14   |  1110  |
|    F     |   15   |  1111  |

二进制转换十六进制口诀‌：四位一组，查表替换，高位补零。反过来十六进制转换二进制也是一样。  

| 1111  | 0101  | 1011  | 1001  | 1110  | 0001  |
| :---: | :---: | :---: | :---: | :---: | :---: |
|   F   |   5   |   B   |   9   |   E   |   1   |

十进制转换十六进制口诀:除16取余，倒序排列，10-15换字母  
| 步骤  | 十进制数 |   除以16    |   商    | 余数  |          备注          |
| :---: | :------: | :---------: | :-----: | :---: | :--------------------: |
|   1   | 16103905 | 16103905÷16 | 1006494 |   1   |       记录余数1        |
|   2   | 1006494  | 1006494÷16  |  62905  | 14(E) |       记录余数14       |
|   3   |  62905   |  62905÷16   |  3931   |   9   |       记录余数9        |
|   4   |   3931   |   3931÷16   |   245   | 11(B) |       记录余数11       |
|   5   |   245    |   245÷16    |   15    |   5   |       记录余数5        |
|   6   |    15    |    15÷16    |    0    | 15(F) | 记录余数15,商为0，停止 |

余数倒序,最终结果为F5B9E1。  

十六进制数转换十进制数公式:∑(每位十六进制值×16<sup>位置索引</sup>)。位置索引规则‌：从右向左，从0开始计数。  
F5B9E1 = 15×16<sup>5</sup> + 5×16<sup>4</sup> + 11×16<sup>3</sup> + 9×16<sup>2</sup> + 14×16<sup>1</sup> + 1×16<sup>0</sup>  
= 15728640 + 327680 + 45056 + 2304 + 224 + 1  
= 16103905  

> 🤞`知识点`  
现代计算机把整数存储在偶数字节的字中,一般是2、4、8或16字节,一个字节是8位,正好是两个十六进制数,所以内存中的任意二进制整数总是精确对应于若干个十六进制数。  

> 🤞`知识点`  
数制转换记忆规律:转十乘,十转除,十六转二4分组。  

### 1.9.3 负的二进制数
- 原码：绝对值二进制码  
- 反码：原码二进制数字，0变1，1变0  
- 补码：正数的补码等于原码，负数的补码等于反码+1  

> 👉`重点`  
补码的核心是‌用加法代替减法‌，同时解决负数表示问题。做加减法计算时‌所有数用补码相加，舍弃溢出位，即得结果。  

### 1.9.4 八进制数
> 👉`重点`  
八进制值有一个前导0！076是八进制,而76是十进制,一定要注意分清。  

### 1.9.5 Big-Endian和Little-Endian系统

- Big-Endian(大端序),最高位字节在低字节地址  
    - 网络协议 (TCP/IP 标准规定使用大端序，称为“网络字节序”)。
    - 某些处理器架构：如 Motorola 68000, IBM POWER (包括某些 PowerPC), Sun SPARC (历史主流), Java虚拟机内部表示等。

| 地址  | 0x1000 | 0x1001 | 0x1002 | 0x1003 |
| :---: | :----: | :----: | :----: | :----: |
| 内容  |  0x12  |  0x34  |  0x56  |  0x78  |
- Little-endian (小端序),最低位字节在低字节地址  
    - ‌x86 和 x86-64 架构 (Intel, AMD 处理器)‌。
    - ARM 处理器 (通常可配置，但移动设备、嵌入式系统常用小端)。
    - DEC VAX, 6502 等。

| 地址  | 0x1000 | 0x1001 | 0x1002 | 0x1003 |
| :---: | :----: | :----: | :----: | :----: |
| 内容  |  0x78  |  0x56  |  0x34  |  0x12  |

`理解重要性`
- 数据交换：‌ 当数据在不同架构（大端和小端）的计算机之间传输（通过网络、文件等）时，如果不进行字节序转换，接收方读取到的数值将是错误的！这也是为什么网络协议强制使用大端序（网络字节序），发送方和接收方在进行网络通信前都需要调用函数 (htonl, htons, ntohl, ntohs) 在主机字节序和网络字节序之间进行转换。
- ‌文件格式：‌ 文件格式需要明确定义其数据的字节序，以确保在不同系统上都能正确读取。常见格式如 PNG、JPEG 通常使用大端序。
- ‌调试：‌ 调试器查看内存内容时，理解字节序对于正确解读数值至关重要。
- ‌低级编程：‌ 直接操作内存或进行二进制数据处理时，必须考虑字节序。

> 🀄`结论`  
理解这两种字节序对于计算机体系结构、网络编程、文件格式解析和底层系统编程至关重要。现代计算机系统中，x86/x64 的绝对主导地位使得小端序在日常开发中更为常见，但在网络传输和跨平台数据交换时，大端序（网络字节序）是必须遵循的标准。  

### 1.9.6 浮点数
- 浮点数一般只是精确数字的近似表示。
- 不同量级的数字执行相加或相减操作要小心,有可能不产生效果。
- 两个几乎相等的数相减,结果可能只有一两位小数精度。

### 1.11 C++源字符
```c++
// Ex1_02.cpp
// Using escape sequences
#include <iostream>
int main(){
    std::cout <<"\"Least \'said\' \\\n\t\tsonnest \'mended\'.\"" << std::endl;
    std::cin.get();
    return 0;
}
```
### 1.13 练习
1. 创建\编译\链接\执行一个程序,在屏幕上输出文本"Hello World"。
```c++
#include <iostream>
int main()
{
    std::cout << "Hello World" << std::endl;
    std::cin.get();
    return 0;
}
```
2. 创建并执行一个程序,在一行上输出自己的姓名,在下一行上输出年龄。
```c++
#include <iostream>
int main()
{
    std::cout << "李白\n18岁" << std::endl;
    std::cin.get();
    return 0;
}
```
3. 下面的程序有几处编译错误。请指出这些错误并更正,使程序能正确编译并运行。
```c++
#import <iostream> //少分号
Int main //I要小写,同时函数名少括号
{
    std:cout << "Hola Mundo!" << std:endl //两个std:都少一个":",而且语句结尾少";"
}
```
```c++
#include <iostream> //因编译器不支持#import,改为#include
int main()
{
    std::cout << "Hola Mundo!" << std::endl;
    std::cin.get();
    return 0;
}
```
# 第2章 基本数据类型
## 2.1 变量、数据和数据类型
### 2.1.1 定义整形变量
🈯定义:包含初始值的花括号称为`列表初始化`。  

```c++
int a = 4;       // 拷贝初始化（copy initialization）
int b(4);        // 直接初始化（direct initialization），书中称为函数初始化，不准确。不过此种初始化方式容易和函数定义混淆。
int c{4};        // 列表初始化（list initialization，C++11 引入）
int d = {4};     // 拷贝列表初始化（结合拷贝和列表语法）
```
- 实践只要使用列表初始化即可,其它方法熟悉,方便阅读其他代码。  
- 列表初始化允许使用表达式,但表达式应提前定义。  
- int类型一般为4字节,存储范围为-2147483648～+2147483647。  
- 初始化列表能够避免缩窄转换和以相同方式初始化所有变量，常被称为`统一初始化`。  

```c++
//Ex2_01.cpp
#include <iostream>
int main()
{
    int apple_count{15};
    int orange_count{5};
    int fruit_total{apple_count + orange_count};

    std::cout << "The value of apple_count is " << apple_count << std::endl;
    std::cout << "The value of orange_count is " << orange_count << std::endl;
    std::cout << "The value of fruit_count is " << fruit_total << std::endl;
    std::cin.get();
    return 0;
}
```
|  类型名   | 类型的大小(字节) |                    值域                    |
| :-------: | :--------------: | :----------------------------------------: |
|   char    |        1         |                 -128～+127                 |
|   short   |        2         |                 -256～+255                 |
|    int    |        4         |          -2147483648～+2147483647          |
|   long    |       4或8       |            与int或long long相同            |
| long long |        8         | -9223372036854775808～+9223372036854775808 |

- signed:有符号整数(+、-),默认就是signed。单独的signed类型特指signed int。
- unsigned:无符号整数(+)。单独的unsigned类型特指unsigned int。
- char是不同于signed和unsigned的整数类型,不带修饰符一般只用于存储字符，如果要存储数字，必须带修饰符,或者用std::byte更合适(C++20)。

### 2.1.2 零初始化
- int counter {0}; 与int counter { };效果相同。
- 对于所有基本数值类型,空初始化列表总是被视为包含数字0。

### 2.1.3 定义有固定值的变量
- 使用const关键字,即定义常量。
- const unsigned toe_count {10};

## 2.2 整形字面量
### 2.2.1 十进制整形字面量
- 整数字面量：如123
- 浮点数字面量：如3.14
- 字符字面量：如'a'
- 字符串字面量：如"hello"
- 布尔字面量：如true/false
- 指针字面量：如nullptr
- 自定义字面量

字面量可以有后缀,如-123L、98U、12345ULL等，大小写不限，U和L前后不限。一般情况下实际编程不写后缀，但在某些情况下，需要添加正确的字面量后缀，例如初始化一个auto类型的变量或者调用有字面量实参的重载函数（第8章介绍）时。  
从C++14开始，可以使用单引号字符'使数值字面量更便于阅读,如22'333、-1'234LL、12'345ULL等。
### 2.2.2 十六进制整形字面量
